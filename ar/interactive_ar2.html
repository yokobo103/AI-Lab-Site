<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Hand Magic Demo</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
    video {
      display: none; /* 映像は隠しておく。キャンバスに描く用。*/
    }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas"></canvas>

  <!-- TensorFlow.js 本体 -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>

  <!-- 手検出モデル Handpose -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose"></script>

  <script>
    // 指の本数を数える関数
    function countFingers(landmarks) {
      const wrist = landmarks[0]; // 手首
      const fingers = [
        { tip: 4, base: 1 },   // 親指
        { tip: 8, base: 5 },   // 人差し指
        { tip: 12, base: 9 },  // 中指
        { tip: 16, base: 13 }, // 薬指
        { tip: 20, base: 17 }  // 小指
      ];

      let count = 0;
      for (const f of fingers) {
        const tip = landmarks[f.tip];
        const base = landmarks[f.base];
        const distTip  = Math.hypot(tip[0]  - wrist[0], tip[1]  - wrist[1]);
        const distBase = Math.hypot(base[0] - wrist[0], base[1] - wrist[1]);
        if (distTip > distBase + 15) count++;
      }
      return count;
    }

    // 炎エフェクト
    function drawFlame(ctx, x, y, t) {
      const jitter = Math.sin(t / 100) * 5;
      const grad = ctx.createLinearGradient(x, y - 80, x, y);
      grad.addColorStop(0, "rgba(255, 255, 0, 0.9)");
      grad.addColorStop(0.5, "rgba(255, 140, 0, 0.8)");
      grad.addColorStop(1, "rgba(255, 0, 0, 0.6)");

      ctx.save();
      ctx.translate(jitter, 0);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.quadraticCurveTo(x - 25, y - 40, x, y - 80);
      ctx.quadraticCurveTo(x + 25, y - 40, x, y);
      ctx.closePath();
      ctx.fillStyle = grad;
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(x, y - 10);
      ctx.quadraticCurveTo(x - 35, y - 60, x, y - 100);
      ctx.quadraticCurveTo(x + 35, y - 60, x, y - 10);
      ctx.closePath();
      ctx.fillStyle = "rgba(255, 80, 0, 0.5)";
      ctx.fill();
      ctx.restore();
    }

    // バリア（シールド）エフェクト
    function drawBarrier(ctx, x, y, t) {
      const baseRadius = 90;
      const pulse = Math.sin(t / 300) * 10;
      const r = baseRadius + pulse;

      const grad = ctx.createRadialGradient(x, y, r * 0.2, x, y, r);
      grad.addColorStop(0, "rgba(180, 255, 255, 0.6)");
      grad.addColorStop(0.5, "rgba(0, 200, 255, 0.25)");
      grad.addColorStop(1, "rgba(0, 120, 255, 0.05)");

      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fillStyle = grad;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(0, 255, 255, 0.9)";
      ctx.lineWidth = 4;
      ctx.stroke();

      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x - r * 0.8, y);
      ctx.lineTo(x + r * 0.8, y);
      ctx.moveTo(x, y - r * 0.8);
      ctx.lineTo(x, y + r * 0.8);
      ctx.strokeStyle = "rgba(200, 255, 255, 0.6)";
      ctx.stroke();
    }

    (async () => {
      const video = document.getElementById('video');
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      // 1. カメラ取得
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'user' },
        audio: false
      });
      video.srcObject = stream;

      await new Promise(resolve => { video.onloadedmetadata = resolve; });

      // キャンバスはウィンドウサイズいっぱい（後で動画を等倍スケールで配置）
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      // 2. モデル読み込み
      await tf.ready();
      const model = await handpose.load();

      // 3. 描画ルーチン
      async function render() {
        const t = performance.now();

        // 手の位置推定
        const predictions = await model.estimateHands(video);

        // アスペクト比を維持しつつ、ウィンドウに収まる最大サイズで描画（左右反転）
        const scale = Math.min(canvas.width / video.videoWidth, canvas.height / video.videoHeight);
        const drawW = video.videoWidth * scale;
        const drawH = video.videoHeight * scale;
        const offsetX = (canvas.width - drawW) / 2;
        const offsetY = (canvas.height - drawH) / 2;

        ctx.save();
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(video, offsetX, offsetY, drawW, drawH);
        ctx.restore();

        if (predictions.length > 0) {
          const landmarks = predictions[0].landmarks;

          // 手の中点っぽい位置：人差し指付け根を使う
          const [hx, hy] = landmarks[5];
          const [fx, fy] = landmarks[8]; // 人差し指先端

          // スクリーン座標にスケールしつつ左右反転
          const screenHx = canvas.width - (offsetX + hx * scale);
          const screenHy = offsetY + hy * scale;
          const screenFx = canvas.width - (offsetX + fx * scale);
          const screenFy = offsetY + fy * scale;

          const fingerCount = countFingers(landmarks);

          // 本数表示（手の近く）
          ctx.font = "36px sans-serif";
          ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
          ctx.strokeStyle = "rgba(0, 0, 0, 0.7)";
          ctx.lineWidth = 4;
          const text = fingerCount.toString();
          ctx.strokeText(text, screenHx + 20, screenHy - 20);
          ctx.fillText(text, screenHx + 20, screenHy - 20);

          // 本数でエフェクト切替
          if (fingerCount <= 1) {
            drawFlame(ctx, screenHx, screenHy, t);
          } else if (fingerCount >= 4) {
            drawBarrier(ctx, screenHx, screenHy, t);
          } else {
            ctx.beginPath();
            ctx.arc(screenFx, screenFy, 25, 0, Math.PI * 2);
            ctx.strokeStyle = "rgba(255, 255, 0, 0.8)";
            ctx.lineWidth = 5;
            ctx.stroke();
          }
        }

        requestAnimationFrame(render);
      }

      render();
    })();
  </script>
</body>
</html>

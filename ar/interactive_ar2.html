<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Hand Counter Demo</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
    video {
      display: none; /* 映像は隠しておく。キャンバスに描く用。*/
    }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas"></canvas>

  <!-- TensorFlow.js 本体 -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>

  <!-- 手検出モデル Handpose -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose"></script>

  <script>
    // 指の本数を数える関数（手の大きさスケールを考慮）
    function countFingers(landmarks) {
      const wrist = landmarks[0];     // 手首
      const palmRef = landmarks[9];   // 中指付け根あたり
      const palmSize = Math.hypot(
        palmRef[0] - wrist[0],
        palmRef[1] - wrist[1]
      ) || 1; // 0割り防止

      const fingers = [
        { tip: 4, base: 1 },   // 親指
        { tip: 8, base: 5 },   // 人差し指
        { tip: 12, base: 9 },  // 中指
        { tip: 16, base: 13 }, // 薬指
        { tip: 20, base: 17 }  // 小指
      ];

      let count = 0;
      for (const f of fingers) {
        const tip = landmarks[f.tip];
        const base = landmarks[f.base];

        const distTip  = Math.hypot(tip[0]  - wrist[0], tip[1]  - wrist[1]);
        const distBase = Math.hypot(base[0] - wrist[0], base[1] - wrist[1]);

        // 先端が付け根より「十分に」遠ければ伸びているとみなす
        if (distTip - distBase > palmSize * 0.25) {
          count++;
        }
      }

      // ノイズ対策で 1 本だけ浮いた時は 0 に丸める
      if (count === 1) {
        return 0;
      }
      return count;
    }

    (async () => {
      const video = document.getElementById('video');
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      // 1. カメラ取得
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'user' },
        audio: false
      });
      video.srcObject = stream;

      await new Promise(resolve => { video.onloadedmetadata = resolve; });

      // キャンバスはウィンドウサイズいっぱい
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      // 2. モデル読み込み
      await tf.ready();
      const model = await handpose.load();

      // 3. 描画ループ
      async function render() {
        // 手の位置推定
        const predictions = await model.estimateHands(video);

        // アスペクト比を維持しつつ、ウィンドウに収まる最大サイズで描画（左右反転）
        const scale = Math.min(
          canvas.width / video.videoWidth,
          canvas.height / video.videoHeight
        );
        const drawW = video.videoWidth * scale;
        const drawH = video.videoHeight * scale;
        const offsetX = (canvas.width - drawW) / 2;
        const offsetY = (canvas.height - drawH) / 2;

        // 背景（カメラ映像）を描画：左右反転
        ctx.save();
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(video, offsetX, offsetY, drawW, drawH);
        ctx.restore();

        // 手ごとに処理（複数手対応）
        for (const hand of predictions) {
          const landmarks = hand.landmarks;

          // 手の中点っぽい位置：人差し指付け根を使う
          const [hx, hy] = landmarks[5];

          // スクリーン座標にスケールしつつ左右反転
          const screenHx = canvas.width - (offsetX + hx * scale);
          const screenHy = offsetY + hy * scale;

          const fingerCount = countFingers(landmarks);

          // 本数表示（手の近く）
          ctx.font = "36px sans-serif";
          ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
          ctx.strokeStyle = "rgba(0, 0, 0, 0.7)";
          ctx.lineWidth = 4;

          const text = fingerCount.toString();
          ctx.strokeText(text, screenHx + 20, screenHy - 20);
          ctx.fillText(text, screenHx + 20, screenHy - 20);

          // 参考までに、手の位置マーカー（小さな円）
          ctx.beginPath();
          ctx.arc(screenHx, screenHy, 8, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(0, 255, 255, 0.7)";
          ctx.fill();
        }

        requestAnimationFrame(render);
      }

      render();
    })();
  </script>
</body>
</html>

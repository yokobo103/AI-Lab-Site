<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Hand Counter + Face GLB</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
    video {
      display: none;
    }
    /* 顔の前に重ねる glb */
    #face-model {
      position: fixed;
      top: 0;
      left: 0;
      width: 200px;
      height: 200px;
      transform: translate(-50%, -50%) scaleX(-1); /* 中心合わせ＋左右反転 */
      pointer-events: none;
      z-index: 10;
      display: none;
    }
  </style>
</head>
<body>
  <video id="video" playsinline></video>
  <canvas id="canvas"></canvas>

  <!-- ★ここに自分の glb を指定 -->
  <model-viewer id="face-model"
                src="../models/cat2.glb"
                autoplay
                disable-tap
                disable-pan
                disable-zoom
                camera-controls="false"
                gesture-controls="none"
            >
  </model-viewer>

  <!-- MediaPipe -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <!-- model-viewer 本体 -->
  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>

  <script>
    /************** 指本数カウント（左右判定つき） **************/
    function countFingers(landmarks, handedness) {
      let count = 0;

      // 親指（左右で判定が変わる）
      const thumbTip = landmarks[4];
      const thumbIP  = landmarks[3];
      let thumbExtended = false;

      if (handedness === "Right") {
        // 右手 → 親指は画面左方向に伸びる
        thumbExtended = thumbTip.x < thumbIP.x;
      } else {
        // 左手 → 親指は画面右方向に伸びる
        thumbExtended = thumbTip.x > thumbIP.x;
      }
      if (thumbExtended) count++;

      // 人差し指〜小指
      const fingers = [
        { tip: 8, base: 5 },
        { tip: 12, base: 9 },
        { tip: 16, base: 13 },
        { tip: 20, base: 17 }
      ];
      for (const f of fingers) {
        const tip  = landmarks[f.tip];
        const base = landmarks[f.base];
        if (tip.y < base.y) count++; // 先端が付け根より上
      }
      return count;
    }

    window.onload = () => {
      const video = document.getElementById("video");
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const faceModel = document.getElementById("face-model");

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      // Hands / Face 共通の描画パラメータ（Face側でも使う）
      let lastDraw = { drawW: 0, drawH: 0, offsetX: 0, offsetY: 0 };

      /************** Hands 初期化 **************/
      const hands = new Hands({
        locateFile: (file) =>
          `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
      });

      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6,
      });

      hands.onResults(onHandsResults);

      /************** FaceMesh 初期化 **************/
      const faceMesh = new FaceMesh({
        locateFile: (file) =>
          `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`,
      });

      faceMesh.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });

      faceMesh.onResults(onFaceResults);

      /************** Camera 共通 **************/
      const camera = new Camera(video, {
        onFrame: async () => {
          // 毎フレーム：Hands → FaceMesh の順に処理
          await hands.send({ image: video });
          await faceMesh.send({ image: video });
        },
        width: 640,
        height: 480,
      });
      camera.start();

      /************** Hands の結果：背景＋指カウンタ描画 **************/
      function onHandsResults(results) {
        ctx.save();
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);

        const videoW = video.videoWidth || 640;
        const videoH = video.videoHeight || 480;
        const scale = Math.min(canvas.width / videoW, canvas.height / videoH);
        const drawW = videoW * scale;
        const drawH = videoH * scale;
        const offsetX = (canvas.width - drawW) / 2;
        const offsetY = (canvas.height - drawH) / 2;

        ctx.drawImage(video, offsetX, offsetY, drawW, drawH);
        ctx.restore();

        lastDraw = { drawW, drawH, offsetX, offsetY };

        if (results.multiHandLandmarks && results.multiHandLandmarks.length) {
          for (let i = 0; i < results.multiHandLandmarks.length; i++) {
            const lm = results.multiHandLandmarks[i];
            const handedness = results.multiHandedness[i].label; // "Right" or "Left"

            const fingerCount = countFingers(lm, handedness);

            // 人差し指付け根
            const hx = lm[5].x * drawW + offsetX;
            const hy = lm[5].y * drawH + offsetY;

            const screenX = canvas.width - hx; // 左右反転
            const screenY = hy;

            ctx.font = "40px sans-serif";
            ctx.fillStyle = "rgba(255,255,255,0.95)";
            ctx.strokeStyle = "rgba(0,0,0,0.7)";
            ctx.lineWidth = 5;
            ctx.strokeText(fingerCount, screenX + 20, screenY - 20);
            ctx.fillText(fingerCount, screenX + 20, screenY - 20);

            ctx.beginPath();
            ctx.arc(screenX, screenY, 8, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(0,255,255,0.8)";
            ctx.fill();
          }
        }
      }

      /************** FaceMesh の結果：顔位置に glb を配置 **************/
      function onFaceResults(results) {
        if (
          !results.multiFaceLandmarks ||
          results.multiFaceLandmarks.length === 0 ||
          lastDraw.drawW === 0
        ) {
          faceModel.style.display = "none";
          return;
        }

        const lm = results.multiFaceLandmarks[0];

        // 顔領域のバウンディングボックス
        let minX = 1,
          maxX = 0,
          minY = 1,
          maxY = 0;
        for (const p of lm) {
          if (p.x < minX) minX = p.x;
          if (p.x > maxX) maxX = p.x;
          if (p.y < minY) minY = p.y;
          if (p.y > maxY) maxY = p.y;
        }

        const { drawW, drawH, offsetX, offsetY } = lastDraw;

        const cx = ((minX + maxX) / 2) * drawW + offsetX;
        const cy = ((minY + maxY) / 2) * drawH + offsetY;

        const screenX = canvas.width - cx; // 左右反転
        const screenY = cy;

        const faceWidthPx = (maxX - minX) * drawW;
        const size = faceWidthPx * 3.0; // めちゃ大きめ

        faceModel.style.display = "block";
        faceModel.style.left = `${screenX}px`;
        faceModel.style.top = `${screenY}px`;
        faceModel.style.width = `${size}px`;
        faceModel.style.height = `${size}px`;
      }
    };
  </script>
</body>
</html>
